如何判断当前数据库的内存是否已经达到瓶颈？

查看服务器状态，比较物理磁盘的读取和内存读取的比例来判断缓冲池的命中率

show global status like 'innodb%read%'



![](..\..\image\架构\mysql-优化.PNG)



数据库性能优化主要一下几个方面：
　　1、sql语句的执行计划是否正常
　　2、减少应用和数据库的交互次数、同一个sql语句的执行次数
　　3、数据库实体的碎片的整理（特别是对某些表经常进行insert和delete动作，尤其注意，索引字段为系列字段、自增长字段、时间字段，对于业务比较频繁的系统，最好一个月重建一次）
　　4、减少表之间的关联，特别对于批量数据处理，尽量单表查询数据，统一在内存中进行逻辑处理，减少数据库压力（java处理批量数据不可取，尽量用c或者c++ 进行处理，效率大大提升）
　　5、对访问频繁的数据，充分利用数据库cache和应用的缓存
　　6、数据量比较大的，在设计过程中，为了减少其他表的关联，增加一些冗余字段，提高查询性能


## 慢查询日志
1. 常用explain sql 来分析sql的执行情况
2. show profile（首先要设置数据库的profile为1） 来查看sql的执行周期情况
```sql
show profiles;

show profile cpu,block io for query 1; 查看执行的query id 等于1 的那条sql执行情况（cpu,block io CPU和I/O 操作的情况）。
```
3.	开启慢查询日志：

* 查看慢查询查询是否开启情况： show variables like '%slow_query_log%';

* 设置全局的慢查询日志开启: set global slow_query_log=1;

* 查看慢查询的设置时间： show variables like '%long_time_log%'; 默认是10s

* 设置慢查询的阙值时间: set global long_time_log=3； 设置慢查询的阙值时间为3s

```
EXPLAIN你的SELECT查询   
当只要一行数据时使用LIMIT1   
为搜索字段建索引   
从PROCEDURE ANALYSE()取得建议  
尽可能的使用NOT NULL  
无缓冲的查询  
垂直分割 (分割非经常使用字段)  
选择正确的存储引擎 ：MyISAM适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。
使用一个对象关系映射器（Object Relational Mapper） ：Lazy Loading
小心“永久链接” 
```

## SQL的执行计划
explain检查SQL的执行计划

[Table Scan] 表扫描（最慢），对表记录逐行进行检查 
[Clustered Index Scan]聚集索引扫描（较慢），按聚集索引对记录逐行进行检查 
[Index Scan]索引扫描（普通），根据索引滤出部分数据再进行逐行检查 
[Index Seek]索引查找（较快），根据索引定位记录所在位置再取出记录 
[Clustered Index Seek]聚集索引查找（最快），直接根据聚集索引获取记录 




```sql
modified  文件数据最近的修改 时间
explain

```

## 大表优化
摘自https://juejin.im/post/5b24cf7e51882574c020bd56
“select * from source_tab ... Into outfile”和“load data infile ...”语句组合

当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：
- 限定数据的范围： 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。；
- 读/写分离： 经典的数据库拆分方案，主库负责写，从库负责读；
- 缓存： 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；

## 垂直分区：
根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。
简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。 如下图所示，这样来说大家应该就更容易理解了。

- 垂直拆分的优点： 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。
- 垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；


## 水平分区：
保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。
水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。

水平拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 水平拆分最好分库 。  
水平拆分能够支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨界点Join性能较差，逻辑复杂。  
《Java工程师修炼之道》的作者推荐 尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。

下面补充一下数据库分片的两种常见方案：
- 客户端代理： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。 当当网的 Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。
- 中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我们现在谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。


## 扩容
hash Rowkey(id)