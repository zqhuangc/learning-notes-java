## 锁机制
http://blog.csdn.net/mysteryhaohao/article/details/51669741

https://link.juejin.im/?target=https%3A%2F%2Fblog.csdn.net%2Fqq_34337272%2Farticle%2Fdetails%2F80611486

MyISAM和InnoDB存储引擎使用的锁：

MyISAM采用表级锁(table-level locking)。
InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁

锁兼容（Lock Compatible）

自增长与锁   auto-increment counter

SESSION

LOCK、UNLOCK

### 表级锁和行级锁对比：

* 表级锁： Mysql中锁定 粒度最大 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。
* 行级锁： Mysql中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

### 锁分类

* 共享锁（s） 

允许事务读一行数据

共享锁（Share Locks，简记为S）又被称为读锁，其他用户可以并发读取数据，但任何事务都不能获取数据上的排他锁，直到已释放所有共享锁。

共享锁(S锁)又称为读锁，若事务T对数据对象A加上S锁，则事务T只能读A；其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

加锁方式：...... LOCK IN SHARE MODE

* 排他锁（X）

允许事务删除或更新一行数据

排它锁（(Exclusive lock,简记为X锁)）又称为写锁，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。它防止任何其它事务获取资源上的锁，直到在事务的末尾将资源上的原始锁释放为止。在更新操作(INSERT、UPDATE 或 DELETE)过程中始终应用排它锁。


两者之间的区别：

共享锁（S锁）：如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不 能加排他锁。获取共享锁的事务只能读数据，不能修改数据。
排他锁（X锁）：如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获取排他锁的事务既能读数据，又能修改数据。

自动：DELETE

手动：FOR UPDATE

------

意向锁由数据引擎自己维护，用户无法手动操作意向锁
意向锁是表级锁,表示的是一种意向,仅仅表示事务正在读或写某一行记录,在真正加行

**InnoDB另外的两个表级锁：**

- **意向共享锁（IS）：** 表示事务准备给数据行记入共享锁，事务在一个数据行加共享锁前必须先取得该表的IS锁。事务想要获得一张表中某几行的共享锁
- **意向排他锁（IX）：** 表示事务准备给数据行加入排他锁，事务在一个数据行加排他锁前必须先取得该表的IX锁。事务想要获得一张表中某几行的排它锁

不同锁的兼容性







### 锁与索引

不使用索引、主键索引、唯一索引



1. 为什么表上面没有索引或者查询未命中索引时，会锁定整张表？
   一张表是不是一定会有主键索引？是的
   隐藏的聚簇索引
2. 为什么通过唯一索引锁住一行数据，通过主键索引也不能加锁？
   索引存储结构--
   辅助索引  主键的ID



## 锁的算法


InnoDB存储引擎的**锁的算法**有三种：

* Record lock：单个行记录上的锁，锁定索引记录（READ COMMITED）
* Gap lock：间隙锁，锁定一个范围，不包括记录本身（临界点）( READ REPEATABLE)
* Next-key lock：record+gap 锁定一个范围，包含记录本身（临界点），记录不存在时降级为间隙锁

根据查询的范围，区间的划分

相关知识点：
innodb对于行的查询使用next-key lock
Next-locking keying 为了解决 Phantom Problem 幻读问题
当查询的索引含有唯一属性时，将 next-key lock 降级为 record key
Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生  
有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1



### 锁问题

脏读

不可重复读

丢失更新     解决：串行化 ，select 。。。FOR UPDATE