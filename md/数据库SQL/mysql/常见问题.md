https://blog.csdn.net/XiaoHanZuoFengZhou/article/details/80048139



## my.ini 配置 mysql



## 分页查询问题

来源：toutiao.com/i6860655404431442444

- 1、OFFSET 和 LIMIT 有什么问题？
- 2、替代方案

------

> 旁白君：主要去理解 offset 为什么会在大数据量下的查询带来性能问题？
>
> 思考完后，可以在思考下，如果分库分表，你会这么去分页呢？

不需要担心数据库性能优化问题的日子已经一去不复返了。

随着时代的进步，随着野心勃勃的企业想要变成下一个 Facebook，随着为机器学习预测收集尽可能多数据的想法的出现，作为开发人员，我们要不断地打磨我们的 API，让它们提供可靠和有效的端点，从而毫不费力地浏览海量数据。

如果你做过后台开发或数据库架构，你可能是这么分页的：

![img](https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdRzlFVJqV65uUvmIDlOXaN9tibuBiaGBibXfLHkMhnp7P7o5O0yZhmaR25ksBa0QNYcaVRYictzoPrvQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

如果你真的是这么分页，那么我不得不抱歉地说，你这样做是错的。

你不以为然？没关系。Slack、Shopify 和 Mixmax 这些公司都在用我们今天将要讨论的方式进行分页。

我想你很难找出一个不使用 OFFSET 和 LIMIT 进行数据库分页的人。对于简单的小型应用程序和数据量不是很大的场景，这种方式还是能够“应付”的。

如果你想从头开始构建一个可靠且高效的系统，在一开始就要把它做好。

今天我们将探讨已经被广泛使用的分页方式存在的问题，以及如何实现高性能分页。

#### 1、OFFSET 和 LIMIT 有什么问题？

正如前面段落所说的那样，OFFSET 和 LIMIT 对于数据量少的项目来说是没有问题的。

但是，当数据库里的数据量超过服务器内存能够存储的能力，并且需要对所有数据进行分页，问题就会出现。

为了实现分页，每次收到分页请求时，数据库都需要进行低效的全表扫描。

> 什么是全表扫描？全表扫描 (又称顺序扫描) 就是在数据库中进行逐行扫描，顺序读取表中的每一行记录，然后检查各个列是否符合查询条件。这种扫描是已知最慢的，因为需要进行大量的磁盘 I/O，而且从磁盘到内存的传输开销也很大。

这意味着，如果你有 1 亿个用户，OFFSET 是 5 千万，那么它需要获取所有这些记录 (包括那么多根本不需要的数据)，将它们放入内存，然后获取 LIMIT 指定的 20 条结果。

也就是说，为了获取一页的数据：

```
10万行中的第5万行到第5万零20行
```

需要先获取 5 万行。这么做是多么低效？

如果你不相信，可以看看这个例子：

https://www.db-fiddle.com/f/3JSpBxVgcqL3W2AzfRNCyq/1?ref=hackernoon.com

左边的 Schema SQL 将插入 10 万行数据，右边有一个性能很差的查询和一个较好的解决方案。只需单击顶部的 Run，就可以比较它们的执行时间。第一个查询的运行时间至少是第二个查询的 30 倍。

数据越多，情况就越糟。看看我对 10 万行数据进行的 PoC。

https://github.com/IvoPereira/Efficient-Pagination-SQL-PoC?ref=hackernoon.com

现在你应该知道这背后都发生了什么：OFFSET 越高，查询时间就越长。

#### 2、替代方案

你应该这样做：

![img](https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdRzlFVJqV65uUvmIDlOXaNuIcbIRvCqW9X14E3E9huyZcHMkic1BJTPx7RyMqTwQEPHb0DR9HtiaSw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

这是一种基于指针的分页。

你要在本地保存上一次接收到的主键 (通常是一个 ID) 和 LIMIT，而不是 OFFSET 和 LIMIT，那么每一次的查询可能都与此类似。

为什么？因为通过显式告知数据库最新行，数据库就确切地知道从哪里开始搜索（基于有效的索引），而不需要考虑目标范围之外的记录。

比较这个查询：

![img](https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdRzlFVJqV65uUvmIDlOXaNjcwfJe3UFLYZ95IFc656E4Oz2FNUTrUwY7RmHIVtap4BasV1LruHiaQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

和优化的版本：

![img](https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdRzlFVJqV65uUvmIDlOXaNsS5FBKibGSBPlKPq9x3hCUdichNiacxZNpXJzGvznC8ydIpPGxMSfsjQg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

返回同样的结果，第一个查询使用了 12.80 秒，而第二个仅用了 0.01 秒。

要使用这种基于游标的分页，需要有一个惟一的序列字段 (或多个)，比如惟一的整数 ID 或时间戳，但在某些特定情况下可能无法满足这个条件。

我的建议是，不管怎样都要考虑每种解决方案的优缺点，以及需要执行哪种查询。

如果需要基于大量数据做查询操作，Rick James 的文章提供了更深入的指导。

http://mysql.rjweb.org/doc.php/lists

如果我们的表没有主键，比如是具有多对多关系的表，那么就使用传统的 OFFSET/LIMIT 方式，只是这样做存在潜在的慢查询问题。我建议在需要分页的表中使用自动递增的主键，即使只是为了分页。



## MySQL不推荐使用子查询和join



前言：

1.对于mysql，不推荐使用子查询和join是因为本身join的效率就是硬伤，一旦数据量很大效率就很难保证，强烈推荐分别根据索引单表取数据，然后在程序里面做join，merge数据。

2.子查询就更别用了，效率太差，执行子查询时，MYSQL需要创建临时表，查询完毕后再删除这些临时表，所以，子查询的速度会受到一定的影响，这里多了一个创建和销毁临时表的过程。

3.如果是JOIN的话，它是走嵌套查询的。小表驱动大表，且通过索引字段进行关联。如果表记录比较少的话，还是OK的。大的话业务逻辑中可以控制处理。

4.数据库是最底层的，瓶颈往往是数据库。建议数据库只是作为数据store的工具，而不要添加业务上去。

一、应用层关联的优势：

让缓存的效率更高。许多应用程序可以方便地缓存单表查询对应的结果对象。如果关联中的某个表发生了变化，那么就无法使用查询缓存了，而拆分后，如果某个表很少改变，那么基于该表的查询就可以重复利用查询缓存结果了。
将查询分解后，执行单个查询可以减少锁的竞争。
在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。
查询本身效率也可能会有所提升。查询id集的时候，使用IN（）代替关联查询，可以让MySQL按照ID顺序进行查询，这可能比随机的关联要更高效。
可以减少冗余记录的查询。在应用层做关联查询，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能需要重复地访问一部分数据。从这点看，这样的重构还可能会减少网络和内存的消艳。
更进一步，这样做相当于在应用中实现了哈希关联，而不是使用MySQL的嵌套循环关联。某些场景哈希关联的效率要高很多。
二、应用层关联的使用场景：

当应用能够方便地缓存单个查询的结果的时候
当可以将数据分布到不同的MySQL服务器上的时候
当能够使用IN（）的方式代替关联查询的时候
并发场景多，DB查询频繁，需要分库分表
三、不推荐使用join的原因： 

1.DB承担的业务压力大，能减少负担就减少。当表处于百万级别后，join导致性能下降； 

2.分布式的分库分表。这种时候是不建议跨库join的。目前mysql的分布式中间件，跨库join表现不良。 

3.修改表的schema，单表查询的修改比较容易，join写的sql语句要修改，不容易发现，成本比较大，当系统比较大时，不好维护。

四、不使用join的解决方法： 

在业务层，单表查询出数据后，作为条件给下一个单表查询。也就是子查询。 会担心子查询出来的结果集太多。mysql对in的数量没有限制，但是mysql限制整条sql语句的大小。通过调整参数max_allowed_packet ，可以修改一条sql的最大值。建议在业务上做好处理，限制一次查询出来的结果集是能接受的。

五、再来说说join查询的好处：

1.做分页查询：

关联查询的好处时候可以做分页，可以用副表的字段做查询条件，在查询的时候，将副表匹配到的字段作为结果集，用主表去in它，但是问题来了，如果匹配到的数据量太大就不行了，也会导致返回的分页记录跟实际的不一样，解决的方法可以交给前端，一次性查询，让前端分批显示就可以了，这种解决方案的前提是数据量不太，因为sql本身长度有限。



### 互联网公司mysql数据库不要使用join，建议service层采用in等子查询解决方法

互联网公司的业务，往往是并发场景多，DB查询频繁，有一定用户规模后，往往要做分库分表。

阿拉巴巴的淘宝网，是从oracle迁移到mysql。原因是mysql免费，开源。互联网公司起步阶段都穷，往往要采用mysql。oracle太贵了，适合不差钱的行业，如金融，证券，军工，国企，制造业。oracle是RDBMS的NO1，多年数据库技术积累，很多方面强于mysql。

互联网行业，业务请求量大，整个架构，数据库是最底层的，瓶颈往往是数据库。建议数据库只是作为数据store的工具，而不要添加业务上去。

**不使用join的原因：** 

1. DB承担的业务压力大，能减少负担就减少。当表处于百万级别后，join导致性能下降； 
2. 分布式的分库分表。这种时候是不建议跨库join的。目前mysql的分布式中间件，跨库join表现不良。 
3. 修改表的schema，单表查询的修改比较容易，join写的sql语句要修改，不容易发现，成本比较大，当系统比较大时，不好维护。

**不使用join的解决方法：** 

1. 在业务层，单表查询出数据后，作为条件给下一个单表查询。也就是子查询。 
2. 会担心子查询出来的结果集太多。mysql对in的数量没有限制，mysql限制整条sql语句的大小。通过调整参数max_allowed_packet ，可以修改一条sql的最大值。建议在业务上做好处理，限制一次查询出来的结果集是能接受的



### 分布式跨库查询 mysql federated引擎的使用







# 为什么要使用时间戳



在数据库系统中，不同的数据库对时间类型有不同的解释，如Oracle中的date和mysql中的date就不能直接兼容转换

为实现跨平台性，将时间记录为unix时间戳