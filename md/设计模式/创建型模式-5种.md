## 工厂模式
1. 普通工厂模式，就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。
2. 多个工厂方法模式，是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。
3. 静态工厂方法模式，将上面的多个工厂方法模式里的方法置为静态的，不需要创建工厂实例，直接调用即可。
## 抽象工厂模式
工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。
## 单例模式
单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。这样的模式有几个好处：
1. 某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。
2. 省去了new操作符，降低了系统内存的使用频率，减轻GC压力。
3. 有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。  

*静态对象、静态方法创建、构造私有*
### 静态内部类的静态对象
只需要在创建类的时候进行同步，所以只要将创建和getInstance()分开，单独为创建加synchronized关键字，也是可以的
```
补充：采用"影子实例"的办法为单例对象的属性同步更新
```
## 建造者模式（搭配）
* 适用场景  
需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。  
需要生成的产品对象的属性相互依赖，需要指定其生成顺序。  
对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。    
隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。

零件 拼装 成车
## 原型模式
* 思想  
  将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。  

*clone方法执行的是浅拷贝， 在编写程序时要注意这个细节*  
为了要在clone对象时进行深拷贝， 那么就要Clonable接口，覆盖并实现clone方法，除了调用父类中的clone方法得到新的对象， 还要将该类中的引用变量也clone出来,但要彻底深拷贝（虽可以但难）
* 浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。
* 深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。