* 设计模式  
经典在于，解决编写代码的人和调用代码的人双方的痛处

代理模式：只关心执行过程
执行者，被代理人？？？？原理
部分功能被代理
JDK代理
原理：被代理引用 => 接口 => 重新生成类并实现接口 => 重新动态生成class字节码 => 编译

byte[] data = ProxyGenerator.generateProxy("$Proxy0",new Class[]{obj.getClass()})//获取新字节码内容

工厂模式：隐藏复杂处理过程，只关心执行结果
简单工厂，工厂方法，抽象工厂(推荐)
单例模式：从系统开启到停止，只产生一个实例，
解决功能性冲突
7种（饿汉，普通懒汉，线程安全的懒汉，静态内部类，双检锁（DCL），枚举）

委派模式(delegate)：，委托人（拿功劳的，要结果），被委托人（干活的，具体实现）（须与代理区分）
**不关心执行过程，只关心结果，有点类似工厂模式()，但实现原理不一样，持有被委托人引用，类似中介**
方法相同，但一个调用另一个来执行

策略模式：过程不同，结果一样
原型模式：
