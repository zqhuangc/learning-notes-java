# 第一类：通过父类与子类的关系进行实现。
## 策略模式（过程不同，结果一样）
在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。  
在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。  
策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口  
策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种算法做封装。因此，策略模式多用在算法决策系统中，外部用户只需要决定用哪个算法即可。

地图路线

* 适用场景
1. 针对同一类型问题的多种处理方式，仅仅是具体行为有差别时； 
2. 需要安全地封装多种同一类型的操作时； 
3. 出现同一抽象类有多个子类，而又需要使用 if-else 或者 switch-case 来选择具体子类时。
计算
sort
## 模板方法模式
在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。定义一个类，继承该抽象类，重写抽象方法，*通过调用抽象类，实现对子类的调用*  
在一个抽象类中，有一个主方法，再定义1...n个方法，可以是抽象的，也可以是实际的方法，定义一个类，继承该抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用，先看个关系图：。
* 
```模式总结
优点
模板方法模式通过把不变的行为搬移到超类，去除了子类中的重复代码。
子类实现算法的某些细节，有助于算法的扩展。
通过一个父类调用子类实现的操作，通过子类扩展增加新的行为，符合“开放-封闭原则”。

缺点
每个不同的实现都需要定义一个子类，这会导致类的个数的增加，设计更加抽象。

适用场景
在某些类的算法中，用了相同的方法，造成代码的重复。
控制子类扩展，子类必须遵守算法规则。

AQS
concurrent包下
```

# 第二类：两个类之间。
## 观察者模式
都是类和类之间的关系，不涉及到继承，，当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。

```
Observer
Observable Vector
```



## 迭代器模式

迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。这句话包含两层意思：一是需要遍历的对象，即聚集对象，二是迭代器对象，用于对聚集对象进行遍历访问。
## 责任链模式
顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进行动态的调整。  
（Struts2 的拦截器，jsp servlet 的 Filter）

1. 无锁化串行执行
2. 条件式阻断，或执行下一个节点
3. LOG appender，分支

* 职责切分，顺序问题，tomcat filterchain 数组

```java
public interface Handler {
    public boolean accept(Properties options);
    public void execute();
}


for(Handler handler: handlers){
    if(handler.accept(xxx)){
        handler.execute();
    }
}
```



### 拦截器模式 Interceptor

AOP

## 命令模式

命令模式（Command Pattern）是一种数据驱动的设计模式，请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。
（invoker 使用命令对象的入口）
*调用者<---命令<----执行者*

- Receiver接受者角色：该角色就是干活的角色，命令传递到这里是应该被执行的
- Command命令角色：需要执行的所有命令都在这里声明
- Invoker调用者角色：接收到命令，并执行命令  

命令模式的目的就是达到命令的发出者和执行者之间解耦，实现请求和执行分开，熟悉Struts的同学应该知道，Struts其实就是一种将请求和呈现分离的技术，其中必然涉及命令模式的思想！
```
优点
- 类间解耦：调用者角色与接收者角色之间没有任何依赖关系，调用者实现功能时只需调用Command 抽象类的execute方法就可以，不需要了解到底是哪个接收者执行。
- 可扩展性：Command的子类可以非常容易地扩展，而调用者Invoker和高层次的模块Client不产生严 重的代码耦合。
- 命令模式结合其他模式会更优秀：命令模式可以结合责任链模式，实现命令族解析任务；结合模板方法模式，则可以减少 Command子类的膨胀问题。
```
# 第三类：类的状态
## 状态模式
在状态模式（State Pattern）中，类的行为是基于它的状态改变的。我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。(类比根据状态，执行不同方法)  
核心思想就是：当对象的状态改变时，同时改变其行为，很好理解！就拿QQ来说，有几种状态，在线、隐身、忙碌等，每个状态对应不同的操作，而且你的好友也能看到你的状态，所以，状态模式就两点：
1. 可以通过改变状态来获得不同的行为。
2. 你的好友能同时看到你的变化。

## 备忘录模式
备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。
通俗的讲下：假设有原始类A，A中有各种属性，A可以决定需要备份的属性，备忘录类B是用来存储A的一些内部状态，类C呢，就是一个用来存储备忘录的，且只能存储，不能修改等操作。
（数据库的事务管理）
# 第四类：通过中间类
## 访问者模式（不改变结构进行扩展）
（根据传入对象不同执行不同操作）？方法重载或反射
在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。
访问者模式的优点是增加操作很容易，因为增加操作意味着增加新的访问者。访问者模式将有关行为集中到一个访问者对象中，其改变不影响系统数据结构。其缺点就是增加新的数据结构很困难
* 应用场景
  - 场景是:在类层次结构稳定,而操作却面临频繁的变动
  - 解决的问题是:在类层次结构的父类中要添加新的行为,这里所有的子类不得不跟着改动
  - 解决方法是:只须添加一个Visitor就可以将所有子类的必须实现的方法集中到Visitor类中
* 个人理解内容
  维护两个接口，两个接口的多态使用
```
被访问抽象中持有访问接口，提供方法accept(Visitor)接收访问接口，accept中访问接口调用方法接收被访问的实现类（静态分派）（使用this），访问接口的实现中可对被访问类（或其子孙，实现类）根据需要进行扩展，被访问抽象

利用 instanceof 可形成层次
if (viewer instanceof AbstractViewer) {
    ((AbstractViewer)viewer).viewConsumeBill(this);
    return;
}
```
* 应用场景
```
1、数据结构稳定，作用于数据结构的操作经常变化的时候。
2、当一个数据结构中，一些元素类需要负责与其不相关的操作的时候，为了将这些操作分离出去，以减少这些元素类的职责时，可以使用访问者模式。
3、有时在对数据结构上的元素进行操作的时候，需要区分具体的类型，这时使用访问者模式可以针对不同的类型，在访问者类中定义不同的操作，从而去除掉类型判断。
```
* 优缺点
```
优点：
1、使得数据结构和作用于结构上的操作解耦，使得操作集合可以独立变化。
2、添加新的操作或者说访问者会非常容易。
3、将对各个元素的一组操作集中在一个访问者类当中。
4、使得类层次结构不改变的情况下，可以针对各个层次做出不同的操作，而不影响类层次结构的完整性。
5、可以跨越类层次结构，访问不同层次的元素类，做出相应的操作。

缺点：
1、增加新的元素会非常困难。
2、实现起来比较复杂，会增加系统的复杂性。
3、破坏封装，如果将访问行为放在各个元素中，则可以不暴露元素的内部结构和状态，但使用访问者模式的时候，为了让访问者能获取到所关心的信息，元素类不得不暴露出一些内部的状态和结构，就像收入和支出类必须提供访问金额和单子的项目的方法一样。
```
## 中介者模式

中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，持有需要通信类的实例，并支持松耦合，使代码易于维护。
（MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。）
## 解释器模式
解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。

# 其他

责任链

拦截器

观察者

访问者

调节者，不同类间状态互斥，负责状态

























