

### 引言

* 摘自-----左耳听风

#### 认识故障和弹力设计

故障是正常的，而且是常见的 。
故障是不可预测突发的，而且相当难缠



* MTTF 是 Mean Time To Failure，平均故障前的时间，即系统平均能够正常运行多长时间才发生一次故障。系统的可靠性越高，MTTF越长。（注意：从字面上来说，看上去
  有 Failure 的字样，但其实是正常运行的时间。）
* MTTR 是 Mean Time To Recovery，平均修复时间，即从故障出现到故障修复的这段时间，这段时间越短越好。



![](https://ws1.sinaimg.cn/large/006xzusPly1g4s8hqv4nkj30j408gacv.jpg)

#### 隔离设计 Bulkheads

#### 异步通讯设计 Asynchronous

* 请求响应式
* 通过订阅的方式
* 通过 Broker 的方式

#### 幂等性设计 Idempotency

全局 ID

 Twitter  的开源项目 Snowfake 。它是一个分布式 ID 的生成算法。其核心思想是，产生一个 long 型的 ID ，其中：
41bits作为毫秒数。大概可以用69.7年。
10bits作为机器编号（5bits是数据中心，5bits的机器ID），支持1024个实例。
12bits作为毫秒内的序列号。一毫秒可以生成4096个序号。

#### 服务的状态 State

无状态的服务 Stateless

有状态的服务 Stateful



很多系统的高可用的设计都会采取数据在运行时就复制的方案，比如： ZooKeeper 、 Kafka 、 Redis 或是 ElasticSearch 等等。在运行时进行数据复制就需要考虑一致性的问题，所
以，强一致性的系统一般会使用两阶段提交。
这要求所有的结点都需要有一致的结果，这是 CAP 里的 CA 系统。而也有的系统采用的是大多数人一致就可以了，比如 Paxos 算法，这是 CP 系统。



#### 补偿事务 Compensating Transaction

ACID  和 BASE



业务补偿

一般来说，业务的事务补偿都是需要一个工作流引擎的。

#### 重试设计 Retry

* 重试的设计重点主要如下：
* 要确定什么样的错误下需要重试；
* 重试的时间和重试的次数。这种在不同的情况下要有不同的考量。有时候，而对一些不是很重要的问题时，我们应该更快失败而不是重试一段时间若干次。比如一个前端的交互需
  要用到后端的服务。这种情况下，在面对错误的时候，应该快速度失败报错（比如：网络错误请重试）。而面对其它的一些错误，比如流控，那么应该使用指数退避的方式，以避
  免造成更多的流量。
* 如果超过重试次数，或是一段时间，那么重试就没有意义了。这个时候，说明这个错误不是一个短暂的错误，那么我们对于新来的请求，就没有必要再进行重试了，这个时候对新
  的请求直接返回错误就好了。但是，这样一来，如果后端恢复了，我们怎么知道呢，此时需要使用我们的熔断设计了。这个在后面会说。
* 重试还需要考虑被调用方是否有幂等的设计。如果没有，那么重试是不安全的，可能会导致一个相同的操作被执行多次。
* 重试的代码比较简单也比较通用，完全可以不用侵入到业务代码中。这里有两个模式。一个是代码级的，像Java那样可以使用Annotation的方式（在Spring中你可以用到这样的
  注解），如果没有注解也可以包装在底层库或是 SDK 库中不需要让上层业务感知到。另外一种是走 Service Mesh 的方式（关于 Service Mesh 的方式，会在后面的文章中介
  绍）。
* 对于有事务相关的操作。我们可能会希望能重试成功，而不至于走业务补偿那样的复杂的回退流程。对此，我们可能需要一个比较长的时间来做重试，但是我们需要保存住请求的
  上下文，这可能对程序的运行有比较大的开销，因此，有一些设计会先把这样的上下文暂存在本机或是数据库中，然后腾出资源来去做别的事，过一会再回来把之前的请求从存储
  中捞出来重试。

#### 熔断设计 Circuit Breaker
#### 限流设计 Throttle

#### 降级设计 degradation