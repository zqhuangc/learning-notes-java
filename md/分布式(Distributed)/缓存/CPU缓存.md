典型的**CPU**有三级缓存，距离核心越近，速度越快，空间越小。L1 一般 32k，L2 一般 256k，L3 一般12M。内存速度需要200个 CPU 周期，CPU 缓存需要1个CPU周期。

MESI协议。现在主流的处理器都是用它来保证缓存的相干性和内存的相干性。  
M、E、S和I代表使用MESI协议时缓存行所处的四个状态:  
M(修改，Modified)：本地处理器已经修改缓存行, 即是脏行, 它的内容与内存中的内容不一样. 并且此cache只有本地一个拷贝(专有).  
E(专有，Exclusive)：缓存行内容和内存中的一样, 而且其它处理器都没有这行数据.  
S(共享，Shared)：缓存行内容和内存中的一样, 有可能其它处理器也存在此缓存行的拷贝.   
I(无效，Invalid)：缓存行失效, 不能使用.  

* 缓存行的四种状态转换：
```
初始：一开始时，缓存行没有加载任何数据，所以它处于I状态。
本地写(Local Write)：如果本地处理器写数据至处于I状态的缓存行，则缓存行的状态变成M。
本地读(Local Read)：如果本地处理器读取处于I状态的缓存行, 很明显此缓存没有数据给它。此时分两种情况：(1)其它处理器的缓存里也没有此行数据，则从内存加载数据到此缓存行后，再将它设成E状态，表示只有我一家有这条数据，其它处理器都没有；(2)其它处理器的缓存有此行数据，则将此缓存行的状态设为S状态。P.S.如果处于M状态的缓存行，再由本地处理器写入/读出，状态是不会改变的。
远程读(Remote Read)：假设有两个处理器c1和c2。如果c2需要读另外一个处理器c1的缓存行内容，c1需要把它缓存行的内容通过内存控制器(Memory Controller)发送给c2，c2接到后将相应的缓存行状态设为S。在设置之前，内存也得从总线上得到这份数据并保存。
远程写(Remote Write)：其实确切地说不是远程写，而是c2得到c1的数据后，不是为了读，而是为了写，也算是本地写，只是c1也拥有这份数据的拷贝，这该怎么办呢？c2将发出一个RFO(Request For Owner)请求，它需要拥有这行数据的权限，其它处理器的相应缓存行设为I，除了它自已，谁不能动这行数据。这保证了数据的安全，同时处理RFO请求以及设置I的过程将给写操作带来很大的性能消耗。
```
* 什么时候会发生RFO请求呢？  

有以下两种：
1. 线程的工作从一个处理器移到另一个处理器，它操作的所有缓存行都需要移到新的处理器上。此后如果再写缓存行，则此缓存行在不同核上有多个拷贝，需要发送RFO请求了。
2. 两个不同的处理器确实都需要操作相同的缓存行。

在Java程序中，数组的成员在缓存中也是连续的。其实从Java对象的相邻成员变量也会加载到同一缓存行中。如果多个线程操作不同的成员变量，但是相同的缓存行，**伪共享(False Sharing)问题**就发生了。

* 怎么避免伪共享呢？  

一条缓存行有64字节，而Java程序的对象头固定占8字节(32位系统)或12字节(64位系统默认开启压缩, 不开压缩为16字节)。只需要填6个无用的长整型补上6*8=48字节，让不同的变量处于不同的缓存行，就可以避免伪共享了(64位系统超过缓存行的64字节也无所谓,只要保证不同线程不要操作同一缓存行就可以)，这个办法叫做补齐(Padding)。