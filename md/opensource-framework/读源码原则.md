读源码细节，有两种读的方式，一种是回溯，比如用到某个对象的时候可以逐层追溯，一定会找到该对象的最开始被创建的代码区块，还有一种方式就是自顶向下，逐层分析，一般用在分析某个具体的方法，庖丁解牛，最后拼接出完整的流程

**1、跑不起来的不读**

跑不起来的源码不要读，看也看不懂，很难看懂，事倍功半，读起来还费劲，什么时候这个源码必须得跑起来，跑起来有什么好处就是，你可以用debug-条线跟进去， 举个例子，比如ReentrantLock的lock(方法，没有跑起来的时候，静态的来读源码你会怎么读，按ctr|鼠标单击lock(方法，进入这个方法，会看到这个方法调用了别的方法，你又会按ctrl鼠标单击进入它调用的这个方法，一层层往下，你会发现没法读了,所以如果这个东西能跑起来就不一样了，你会发现与之前鼠标单击跟进的结果不一-样了，原因是因为多态的实现，如果一个方法有很多子类的实现，但是你不知道跟着这条线，它会去实现那个方法，所以你就得全部看一遍。

**2、解决问题就好——目的性**

在实际中解决问题就好，读源码-方面可以解决问题，一方面可以应对面试， 什么意思呢，如果你接手了一个别人改过6手的代码，现在你的老板说这个代码有些问题，你往里边加一些功能或者修改一些bug,你解决问题就好，你不要从头到尾去读去改这个代码，你读你能累死你，目的性要强，解决问题就好。

**3、一条线索到底**

读源码的时候要一条线索到底， 不要只读表面，我们知道一个程序跑起来以后， 可能这个程序非常大，一个main方法有很多的put、get. size各种各样其他的方法，每一个方法你调进去，这个方法很有可能又去调别的方法，你不要每个方法先看遍表面，让后再去里边找，要一条线索到底，就读一个方法，由浅到深看一遍。

**4、无关细节略过**

有那些边界性的东西，在你读第一边的时候， 没必要的时候，你可以先把它略过。







配置如何加载

不同数据结构选择场景





