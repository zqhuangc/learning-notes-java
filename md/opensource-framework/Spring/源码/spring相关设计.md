## 设计模式

经典在于，解决编写代码的人和调用代码的人双方的痛处

7. 代理模式：只关心执行过程
执行者，被代理人？？？？原理
部分功能被代理
JDK代理
原理：被代理引用 => 接口 => 重新生成类并实现接口 => 重新动态生成class字节码 => 编译

byte[] data = ProxyGenerator.generateProxy("$Proxy0",new Class[]{obj.getClass()})//获取新字节码内容
若代理类没实现接口，默认用cglib
1. 工厂模式：隐藏复杂处理过程，只关心执行结果
简单工厂，工厂方法，抽象工厂(推荐)
2. 单例模式：从系统开启到停止，只产生一个实例，
解决功能性冲突
7种（饿汉，普通懒汉，线程安全的懒汉，静态内部类，双检锁（DCL），枚举）

3. 委派模式(delegate)：，委托人（拿功劳的，要结果），被委托人（干活的，具体实现）（须与代理区分）
**不关心执行过程，只关心结果，有点类似工厂模式(固定模式的委派，具体工厂不被感知)，但实现原理不一样，持有被委托人引用，类似中介**
方法相同，但一个调用另一个来执行

IOC容器中 Register

4. 策略模式：过程不同，结果固定
5. 原型模式：过程相同，结果不一样;数据内容一样，实例不同  
克隆  字节码复制
beanutil copy原理
对象流 **序列化**
6. 模板模式    固定的规则（执行流程一样，中间有些步骤不同）
SpringJDBC



Spring 只帮我们管理单例模式 Bean 的完整生命周期，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。

## Spring中类名设计：

- default* 都为默认实现  
- do*      都为具体做操作的方法  
- \*Wrapper 都为包装类  
- *Aware   监听  -> *Processor 处理类
- \*Support 实现功能优化扩展 
- \*Properties 对应配置信息类

### 类扩展设计

限定类名：装载指定类名的类，根据需要可以自定义指定类名的相应类型类，若没有会采用，系统默认提供的处理

## BeanNameGenerator

1. 读取待生成Bean实例的类名称（未必是运行时的实际类型）。
2. 如果类型为空，则判断是否存在parent bean，如果存在，读取parent bean的name + “$child”。
3. 如果parent bean 为空，那么判断是否存在factory bean ，如存在，factory bean name + “$created”。 到此处前缀生成完毕
4. 如果前缀为空，直接抛出异常，没有可以定义这个bean的任何依据。
5. 前缀存在，判断是否为内部bean（innerBean，此处默认为false），如果是，最终为前缀+分隔符+十六进制的hashcode码
6. 如果是顶级bean（top-level bean ），则判断前缀+数字的bean是否已存在，循环查询，知道查询到没有使用的id为止。处理完成（所以这个生成器肯定能保证Bean定义的唯一性，不会出现Bean name覆盖问题
