## 基础

#### 类在 JVM 的加载过程：  

- 从上往下(先声明后使用)   
- 先属性后方法  
- 先静态后动态

#### 继承引用问题

父类 sup = new 子类();    
**sup 可以调用父类非私有属性和方法 + 子类重写成功的方法**



#### 泛型问题  
泛型只作用在编译期，使用反射时将不起作用
**真正涉及类型检查的是它的引用**
**泛型中的引用传递的问题（强转不存在的）**



#### 数组拷贝效率对比


总结： 
（1）从速度上看：System.arraycopy > clone > Arrays.copyOf > for   
（2）for的速度之所以最慢是因为下标表示法每次都从起点开始寻位到指定下标处（现代编译器应该对其有进行优化，改为指针），另外就是它每一次循环都要判断一次是否达到数组最大长度和进行一次额外的记录下标值的加法运算。   
（3）查看Arrays.copyOf的源码可以发现，它其实本质上是调用了System.arraycopy。之所以时间差距比较大，是因为很大一部分开销全花在了Math.min函数上了。  
（4）查看System.arraycopy的源码，可以发现它实质上是通过Jni调用本地方法，及c/c++已经编译成机器码的方法，所以快  

#### 包装类

底层源码，缓存，数据交换#反射,valueOf()

> 两个 Integer 的引用对象传给一个 swap 方法在方法内部进行交换，返回后，两个引用的值是否会发生变化？
>
> -128~127的缓存，IntegerCache
>
> 自动装箱和拆箱
>
> 反射，通过反射修改 private final 属性

* javap -v classfile.class



## 并发

thread#join()



## IO

TCP 发送缓冲区、TCP 接收缓冲区
send、receive

IO 多路复用
同步和异步





























