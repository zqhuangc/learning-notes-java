**摘自网络**

### 什么是序列化？
序列化 持久化到磁盘，类->文件
序列化 (Serialization)将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。

#### 序列化的作用与缺点
通常，对象实例的所有字段都会被序列化，这意味着数据会被表示为实例的序列化数据。这样，能够解释该格式的代码有可能能够确定这些数据的值，而不依赖于该成员的可访问性。类似地，反序列化从序列化的表示形式中提取数据，并直接设置对象状态，这也**与可访问性规则无关**。
对于任何可能包含重要的安全性数据的对象，如果可能，应该使该对象不可序列化。如果它必须为可序列化的，请尝试生成特定字段来保存不可序列化的重要数据。如果无法实现这一点，则应注意该数据会被公开给任何拥有序列化权限的代码，并确保不让任何恶意代码获得该权限。

#### 序列化接口
Serializable空接口
Externalizable
若这个类实现了Externalizable 接口，在writeExternal()方法里定义了哪些属性可以序列化，哪些不可以序列化，所以，对象在经过这里就把规定能被序列化的序列化保存文件，不能序列化的不处理，然后在反序列的时候自动调

用readExternal()方法，根据序列顺序挨个读取进行反序列，并自动封装成对象返回，然后在测试类接收，就完成了反序列。

几种常见Java序列化方式进行实现。包括Java原生以流的方法进行的序列化、Json序列化、FastJson序列化、Protobuff序列化。

### Java原生序列化方法

即通过Java原生流(InputStream和OutputStream之间的转化)的方式进行转化。需要注意的是JavaBean实体类必须实现Serializable接口，否则无法序列化
ObjectOutputStream.writeObject(Object object)
ObjectInputStream.readObject(Object object)
### Json序列化
Json序列化一般会使用jackson包，通过ObjectMapper类来进行一些操作，比如将对象转化为byte数组或者将json串转化为对象。现在的大多数公司都将json作为服务器端返回的数据格式。比如调用一个服务器接口，通常的请求为xxx.json?a=xxx&b=xxx的形式。
mapper.writeValueAsBytes(object);
mapper.readValue(writeValueAsBytes, Object.class);

### FastJson序列化
fastjson 是由阿里巴巴开发的一个性能很好的Java 语言实现的 Json解析器和生成器。特点：速度快，测试表明fastjson具有极快的性能，超越任其他的java json parser。功能强大，完全支持java bean、集合、Map、日期、Enum，支持范型和自省。无依赖，能够直接运行在Java SE 5.0以上版本 
支持Android。使用时候需引入FastJson第三方jar包。  
text=JSON.toJSONString(object);
JSON.parseObject(text,Oobject.class);

### ProtoBuff序列化  
ProtocolBuffer是一种轻便高效的结构化数据存储格式，可以用于结构化数据序列化。适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。
优点：跨语言；序列化后数据占用空间比JSON小，JSON有一定的格式，在数据量上还有可以压缩的空间。
缺点：它以二进制的方式存储，无法直接读取编辑，除非你有 .proto 定义，否则无法直接读出 Protobuffer的任何内容。
其与thrift的对比：两者语法类似，都支持版本向后兼容和向前兼容，thrift侧重点是构建跨语言的可伸缩的服务，支持的语言多，同时提供了全套RPC解决方案，可以很方便的直接构建服务，不需要做太多其他的工作。 Protobuffer主要是一种序列化机制，在数据序列化上进行性能比较，Protobuffer相对较好。

ProtoBuff序列化对象可以很大程度上将其压缩，可以大大减少数据传输大小，提高系统性能。对于大量数据的缓存，也可以提高缓存中数据存储量。原始的ProtoBuff需要自己写.proto文件，通过编译器将其转换为java文件，显得比较繁琐。百度研发的jprotobuf框架将Google原始的protobuf进行了封装，对其进行简化，仅提供序列化和反序列化方法。其实用上也比较简洁，通过对JavaBean中的字段进行注解就行，不需要撰写.proto文件和实用编译器将其生成.java文件，百度的jprotobuf都替我们做了这些事情了。 


#### 反序列化读取顺序
也是最应该注意的，如果你先序列化对象A后序列化B，那么在反序列化的时候一定记着JAVA规定先读到的对象
是先被序列化的对象，不要先接收对象B，那样会报错.尤其在使用上面的Externalizable的时候一定要注意读取的先后顺序。

实现序列化接口的对象并不强制声明唯一的serialVersionUID，是否声明serialVersionUID对于对象序列化的向上向下的兼容性有很大的影响。我们来做个测试：

如果没有明确指定serialVersionUID，序列化的时候会根据字段和特定的算法生成一个serialVersionUID，当属性有变化时这个id发生了变化，所以反序列化的时候 
就会失败。抛出“本地classd的唯一id和流中class的唯一id不匹配”。  
强烈建议使用 private 修饰符显示声明 serialVersionUID（如果可能），原因是这种声明仅应用于直接声明类 – serialVersionUID 字段作为继承成员没有用处。



### 反序列化
注意

（1）反序列化读取的是Java对象的数据，而不是Java类，所以采用反序列化恢复Java对象时，必须提供该Java对象所属类的class文件，否则将会引发classNotFoundException。即person=(Person) ois.readObject（）；

（2）反序列化机制无须通过构造器机制来初始化Java对象，即如果Person对象的构造函数不会执行。

（3）序列化写入Java对象时，和反序列化读取对象的顺序必须对应

（4）一个可序列化类有多个父类时，这些父类要么可以序列化(实现Serializable接口)要么有无参构造器，否则反序列化会抛出异常。如果父类不可序列化但有无参构造器，那么父类的成员值不会序列化到二进制流中。

（5）对于某些成员不想序列化，比如银行密码，用transient修饰（只修饰成员）。

（6）只有第一次调用writeObject()输出对象时才会将对象转换成字节序列，并写入到ObjectOutputStream；后面修改对象再调用writeObject，改变的实例变量也不会被写入。

（7）如果一个类能被序列化，那么子类也可以被序列化

（8）static代表类相关、transient代表对象的临时数据，而序列化和反序列化都是对象和流之间的关系，所以这二者修饰的成员和方法不能序列化。

#### Java序列化算法

（1）所有保存到磁盘中的对象都有一个序列化编号 serialVersionUID。

（2）当程序视图序列化一个对象是，程序先检查该对象是否已被序列化过，只有该对象从未被序列化过，系统才会将该对象转换成字节序列并输出。

（3）如果某个对象已被序列化过，则只是直接输出一个序列化编号，而不是再次重新序列化该对象。

（4）3里面的（6）

#### 关于serialVersionUID：

（1）判定两个类是否兼容性，显示声明（static final） 的好处：提高运行效率，如果没有显示声明，序列化时会通过计算得到编号；提高不同平台兼容性，不同平台计算序列化编号的结果可能不同；提高不同版本程序的兼容性。

### 部分序列化

（1）通过外部序列化，实现Externalizable接口，需要自定义读写操作

（2）使用transient修饰成员


#### 序列化只是针对实例对象
静态成员属于类级别的，所以不能序列化，序列化只是序列化了对象而已，这里“不能序列化”的意思是序列化信息中不包含这个静态成员域