# 类加载机制
## 概述
虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java类型，这就是虚拟机的类加载机制。

## 类加载过程

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括*加载、验证、准备、解析、初始化、使用、卸载*。  
其中类加载的过程包括了*加载、验证、准备、解析、初始化*五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。  
这里简要说明下 Java 中的绑定：绑定指的是把一个方法的调用与方法所在的类(方法主体)关联起来，对 Java 来说，绑定分为*静态绑定*和*动态绑定*：
* 静态绑定：即前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。针对 Java，简单的可以理解为程序编译期的绑定。Java当中的方法只有final，static，private 和构造方法是前期绑定的。
* 动态绑定：即晚期绑定，也叫运行时绑定。在运行时根据具体对象的类型进行绑定。在 Java 中，几乎所有的方法都是后期绑定的。

下面详细讲述类加载过程中每个阶段所做的工作。
+ 加载阶段： 是“类加载”(Class Loading)过程的第一个阶段，在此阶段，虚拟机需要完成以下三件事情：  
  - 通过一个类的全限定名来获取定义此类的二进制字节流。
  - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
  - 在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。
* 验证阶段：是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
* 准备阶段：是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。
* 解析阶段：是虚拟机将常量池内的符号引用替换为直接引用的过程。
* 类初始化：是类加载过程的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。

# 类加载器
* 启动类加载器  
负责将存放在JAVA_HOME\lib目录中的，或者被-Xbootclasspath参数所指定的路径中，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即时放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被java程序直接引用。

* 扩展类加载器：  
负责加载JAVA_HOME\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用该类加载器。
* 应用程序类加载器：  
负责加载用户路径上所指定的类库，开发者可以直接使用这个类加载器，也是默认的类加载器。
* 自定义加载器  

前三种加载器的关系：启动类加载器->扩展类加载器->应用程序类加载器->自定义类加载器。

# 双亲委派模型
从上面的类加载器可以看出，类加载器的加载顺序是自下而上的。

我们把类加载器的这种加载顺序双亲委派模型。其要求除启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不以*继承*关系实现，而是用组合的方式来复用父类的代码。

### 双亲委派模型的工作过程：  
如果一个类加载器接收到了类加载的请求，它首先把这个请求委托给他的父类加载器去完成，每个层次的类加载器都是如此，因此所有的加载请求都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它在搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。
* 好处（优势）：  
java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar中，无论哪个类加载器要加载这个类，最终都会委派给启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果用户自己写了一个名为java.lang.Object的类，并放在程序的Classpath中，那系统中将会出现多个不同的Object类，java类型体系中最基础的行为也无法保证，应用程序也会变得一片混乱。
* 实现：  
在java.lang.ClassLoader的loadClass()方法中，先检查是否已经被加载过，若没有加载则调用父类加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父加载失败，则抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。


# 双亲委任模型破坏
## 如何破坏双亲委任模型？
刚刚我们说过，双亲委任模型不是一个强制性的约束模型，而是一个建议型的类加载器实现方式。在Java的世界中大部分的类加载器都遵循者模型，但也有例外，到目前为止，双亲委派模型有过3次大规模的“被破坏”的情况。

* 第一次：在双亲委派模型出现之前—–即JDK1.2发布之前。 
* 第二次：是这个模型自身的缺陷导致的。我们说，双亲委派模型很好的解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API， 但没有绝对，如果基础类调用会用户的代码怎么办呢？  这不是没有可能的。一个典型的例子就是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器去加载（在JDK1.3时就放进去的rt.jar）,但它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者（SPI， Service Provider Interface）的代码，但启动类加载器不可能“认识“这些代码啊。因为这些类不在rt.jar中，但是启动类加载器又需要加载。怎么办呢？ 

为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：*线程上下文类加载器（Thread Context ClassLoader）*。这个类加载器可以通过java.lang.Thread类的setContextClassLoader方法进行设置。如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过多的话，那这个类加载器默认即使应用程序类加载器。
嘿嘿，有了线程上下文加载器，JNDI服务使用这个线程上下文加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则。但这无可奈何，Java中所有涉及SPI的加载动作基本胜都采用这种方式。例如JNDI，JDBC，JCE，JAXB，JBI等。
* 第三次：为了实现热插拔，热部署，模块化，意思是添加一个功能或减去一个功能不用重启，只需要把这模块连同类加载器一起换掉就实现了代码的热替换。

* 线程上下文类加载器（Thread Context ClassLoader）。
关于破坏双亲委派模型的内容，我们可以使用线程上下文类加载器实现，使用线程上下文加载器，可以让父类加载器请求子类加载器去完成类加载的动作。


## Tomcat 的类加载器是怎么设计的？
以下可视为自定义加载器部分：
* commonLoader：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问；
* catalinaLoader：Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见；
* sharedLoader：各个Webapp共享的类加载器，加载路径中的class对于所有Webapp可见，但是对于Tomcat容器不可见；
* WebappClassLoader：各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可见；
不同应用使用不同的 webapp类加载器，实现应用隔离的效果，webapp类加载器下面是jsp类加载器。   
不同应用共享的jar包可以放到Shared类加载器/shared目录下。

# osgi类加载机制

osgi类加载模型是网状的，可以在模块（Bundle）间互相委托
osgi实现模块化热部署的关键是自定义类加载器机制的实现，每个Bundle都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换
当收到类加载请求时，osgi将按照下面的顺序进行类搜索：
1. 将以java.*开头的类委派给父类加载器加载
2. 否则，将委派列表名单（配置文件org.osgi.framework.bootdelegation中定义）内的类委派给父类加载器加载
3. 否则，检查是否在Import-Package中声明，如果是，则委派给Export这个类的Bundle的类加载器加载
4. 否则，检查是否在Require-Bundle中声明，如果是，则将类加载请求委托给required bundle的类加载器
5. 否则，查找当前Bundle的ClassPath，使用自己的类加载器加载
6. 否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载
7. 否则，查找Dynamic Import-Package（Dynamic Import只有在真正用到此Package的时候才进行加载）的Bundle，委派给对应Bundle的类加载器加载
8. 否则，类查找失败



### Tips

**Class.forName形式加载类时会初始化静态属性和静态代码块，而classLoader.loadClass方法就不会**