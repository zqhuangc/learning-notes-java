
GC回收的时候需要判断三个条件：
* 哪些内存需要回收？
* 什么时候回收？
* 如何回收？

### 栈与堆  
栈中的栈帧随着方法的进入和退出而有条不紊地执行着入栈和出栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，

而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收是动态的，垃圾收集器所关注的是这部分的内存。

但在 JDK1.2 之后，Java 对引用的
概念进行了扩充，将其分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）四种，引用强度依次减弱。
* 强引用：如“Object obj = new Object（）”，这类引用是 Java 程序中最普遍的。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。
* 软引用：它用来描述一些可能还有用，但并非必须的对象。在系统内存不够用时，这类引用关联的对象将被垃圾收集器回收。JDK1.2 之后提供了 SoftReference 类来实现软引用。
* 弱引用：它也是用来描述非需对象的，但它的强度比软引用更弱些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2 之后，提供了 WeakReference 类来实现弱引用。
* 虚引用：最弱的一种引用关系，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例

## GC判定算法
### 引用计数算法
给对象中添加一个引用计数器，每当有
一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的，引用计数算法（Reference Counting）的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法，但是，至少主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。因此目前主流的Java虚拟机都摒弃掉了这种算法。
### 可达性分析算法（根搜索算法）
Java中使用可达性分析（Reachability Analysis）来判定对象是否存活的。通过一系列的称为“GCRoots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）,当一个对象到GCRoots没有任何引用链相连时，则证明此对象是不可用的。

在Java语言中，可以作为GC Roots的对象包括下面几种：
* 虚拟机栈（栈帧中的本地变量表）中的引用对象。
* 方法区中的类静态属性引用的对象。
* 方法区中的常量引用的对象。
* 本地方法栈中JNI（Native方法）的引用对象
```
真正标记一位对象为可回收状态至少要标记两次。
现代的GC都通过可达性分析算法来标记存活对象
```
### GC收集算法
关于标记阶段有几个**关键点**是值得注意的：  
开始进行标记前，需要先暂停应用线程，否则如果对象图一直在变化的话是无法真正去遍历它的。暂停应用线程以便JVM可以尽情地收拾家务的这种情况又被称之为安全点（Safe Point），这会触发一次**Stop The World(STW)**暂停。触发安全点的原因有许多，但最常见的应该就是垃圾回收了。暂停时间的长短并不取决于堆内对象的多少也不是堆的大小，而是存活对象的多少。因此，调高堆的大小并不会影响到标记阶段的时间长短

#### 标记-清除算法（mark-sweep）
算法分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程就是使用可达性算法进行标记的。  
* 标记阶段：标记的过程其实就是前面介绍的可达性分析算法的过程，遍历所有的GC Roots对象，对从GC Roots对象可达的对象都打上一个标识，一般是在对象的header中，将其记录为可达对象；

* 清除阶段：清除的过程是对堆内存进行遍历，如果发现某个对象没有被标记为可达对象（通过读取对象header信息），则将其回收

主要缺点有两个：
* 效率问题，标记和清除两个过程的效率都不高
* 空间问题，标记清除之后会产生大量不连续的内存碎片
#### 复制算法
将可用内存按照容量分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还**存活**着的对象**复制**到另一块上面，然后把**已使用**过的内存空间一次**清理**掉。  
内存分配时不用考虑内存碎片问题，只要一动堆顶指针，按顺序分配内存即可，实现简单，运行高效。代价是将内存缩小为原来的一半。
* 不足：将内存缩小为原来的一半，浪费了一半的内存空间，代价太高；如果不想浪费一半的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。  
复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。
#### 小结
* 效率：复制算法>标记/整理算法 > 标记/清除算法（标记/清除算法有内存碎片问题，给大对象分配内存时可能会触发新一轮垃圾回收）  
* 内存整齐率：复制算法 = 标记/整理算法 > 标记/清除算法  
* 内存利用率：标记/整理算法 = 标记/清除算法 > 复制算法
#### 标记整理算法（Mark-Compact）
标记过程仍然和“标记-清除”一样，但后续不是直接对可回收对象进行清理，而是让所有**存活**对象向一端**移动**，然后直接清理掉**端边界以外**的内存。
* 不足： 
效率不高，不仅要标记存活对象，还要整理所有存活对象的引用地址，在效率上不如复制算法。

#### 分代算法
根据对象存活周期的不同将内存分为几块。一般把Java堆分为新生代和老年代，根据各个年代的特点采用最合适的收集算法。
* 在新生代中，每次垃圾收集时有大批对象死去，只有少量存活，可以选用*复制*算法。
* 而老年代对象存活率高，使用标记清理或者*标记整理*算法。
* 选择年轻代的垃圾收集算法时会更看重执行速度，因为年轻代的垃圾收集工作会频繁执行。
* 另一方面，管理老年代的算法则更注重空间效率，因为老年代会占用堆中的大部分空间，这要求算法必须要处理好垃圾收集的工作，尽量降低堆中的垃圾内存的密度。

##### 分代回收算法

* JVM划分  

  - 新生代：  

刚创建的对象都在新生代，新生代采用复制回收算法。新生代分为三个区，一个Eden区，一般两个Survivor区。大部分对象在Eden区生成，当Eden区域满时，将还存活的对象复制到其中一个Survivor区域，当这个Survivor区域满时，将其中还存活的对象复制到第二个Survivor区域。那么当第二个Survivor区域满时该怎么办呢？那就是将第二个Survivor区域中由第一个Survivor区域复制过来的对象，复制到“老年代”中。
这个过程是有点绕，但是可以想象成面试过程中层层选拔的过程，能力越强的可以想象成生命周期越长的对象。

  - 老年代：  

这个区域中的对象都是在新生代中经历了层层回收后仍然存活的对象，这个区域采用标记整理的算法进行垃圾回收。

  - 持久代：（方法区）  

持久代中用于存放一些静态文件，static常量，常量池等。这块区域对垃圾回收没有显著影响。  

##### 对象晋级
* 年龄阈值：  

VM为每个对象定义了一个对象年龄(Age)计数器, 经第一次Minor GC后 仍然存活, 被移动到Survivor空间中, 并将年龄设为1. 以后对象在Survivor区中每熬 过一次Minor GC年龄就+1. 当增加到一定程度(-XX:MaxTenuringThreshold, 默认 15), 将会晋升到老年代.

* 提前晋升:

 动态年龄判定；如果在Survivor空间中相同年龄所有对象大小的总和大 于Survivor空间的一半, 年龄大于或等于该年龄的对象就可以直接进入老年代, 而无 须等到晋升年龄.

## GC类型
GC有两种类型：Minor GC和Full GC。
* Minor GC  
当新对象生成，并且在Eden申请空间失败时，就会触发Minor GC，对Eden区域进行GC，清理非存活对象。
* Full GC  
对整个堆进行整理，所以比Minor要慢，所以尽可能地减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节。有如下原因可能导致Full GC：
    1. 老年代被写满；
    2. 持久代被写满；
    3. System.gc()被显式调用。
    4. 直接内存满了

Incremental Collecting: 增量回收算法
Concurrent Collecting: 并发回收算法