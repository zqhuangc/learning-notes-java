## GC涉及概念：https://juejin.im/entry/5a5d68796fb9a01cac182b8f#gc的名词

在设计一款垃圾收集器时，有一些选择可供选择：
* 串行 vs 并行  
串行收集，即使在多cpu环境中也是单线程处理垃圾收集工作。当使用并行收集时，垃圾收集任务就会被分为几子任务由不同的线程的执行，不仅仅是在多CPU环境中使用，在单核的系统中也可以使用，只是收集效果可能比使用串行效率还低。所以再单核的环境下尽量使用串行收集。
* 并发 vs 暂停（stop-the-word）  
并发是指垃圾收集线程和应用线程同时执行，并发和stop-the-word并不是互斥的，在一个执行一次垃圾收集的过程中两种情况都可能存在。例如CMS、G1垃圾搜集器。并发式GC会并发执行其垃圾收集任务，但是，可能也会有一些步骤需要以stop-the-world方法执行，导致应用程序暂停。与并发式GC相比，Stop-the-world式的GC更简单.
* Stop The World  
判定垃圾回收的时候要保持整个引用不改变，（我在打扫房间，数地板上的垃圾时，不允许别人清理或者增加垃圾，否则就乱套了）。
所以当可达性分析引用链的时候，就要全部暂停（STOP！），但是这个暂停时间特别短暂，对程序的影响也是微乎其微的，这就是GC卡顿的原因由来。
* 整理 vs 不整理 vs 复制  
这个描述的主要是垃圾被收集以后，对内存碎片的处理方式。  
整理、不整理，垃圾回收以后是否将存活的对象统一移动到一个地方。整理后的内存空间方便后续的对象分配内存，但是更消耗资源和时间，而不整理效率更高存在内存碎片的风险。  
复制，首先将内存分割成两块一样大小的区域，垃圾收集后会将存活的对象拷贝到另一块不同的内存区域。这样做的好处是，拷贝后，源内存区域可以作为一块空的、立即可用的区域对待，方便后续的内存分配，但是这种方法的缺点是需要用额外的时间、空间来拷贝对象。

# HotSpot 分代收集
https://juejin.im/post/5a33d6fd5188252970793a56
https://juejin.im/entry/5ab612e85188255580023199

在JVM中，具体实现有Serial、ParNew、Parallel Scavenge、CMS、 Serial Old（MSC）、Parallel Old、G1等。  
在下图中，你可以看到不同垃圾收集器适合于不同的内存区域，如果两个垃圾收集器之间存在连线，那么表示两者可以配合使用。  
如果当垃圾收集器进行垃圾清理时，必须暂停其他所有的工作线程，直到它完全收集结束。我们称这种需要暂停工作线程才能进行清理的策略为Stop-the-World. 以上收集器中，Serial、ParNew、Parallel Scavenge、 Serial Old、Parallel Old均采用的是Stop-the-World的策略。
## Serial GC
串行回收器主要有两个特点：  
第一，它仅仅使用单线程进行垃圾回收；
第二，它**独占式**的垃圾回收。在串行回收器进行垃圾回收时，Java 应用程序中的线程都需要暂停，等待垃圾回收的完成，这样给用户体验造成较差效果。虽然如此，串行回收器却是一个成熟、经过长时间生产环境考验的极为高效的 回收器。新生代串行处理器使用复制算法，实现相对简单，逻辑处理特别高效，且没有线程切换的开销。

* 使用场景  

在诸如单 CPU 处理器或者较小的应用内存等硬件平台不是特别优越的场合，它的性能表现可以超过并行回收器和并发回收器。  

在 HotSpot 虚拟机中，使用-XX：+UseSerialGC 参数可以指定使用新生代串行回收器和老年代串行回收器。当 JVM 在 Client 模式下运行时，它是默认的垃圾回收器。老年代串行回收器使用的是标记-压缩算法。和新生代串行回收器一样，它也是一个串行的、独占式的垃圾回收器。由于老年代垃圾回收通常会使用比新生代垃圾回收更长的时间，因此，在堆空间较大的应用程序中，一旦老年代串行回收器启动，应用程序很可能会因此停顿几秒甚至更长时间。虽然如此，老年代串行回收器可以 和多种新生代回收器配合使用，同时它也可以作为 CMS 回收器的备用回收器。若要启用老年代串行回收器，可以尝试使用以下参数：-XX:+UseSerialGC:  
**新生代、老年代都使用串行回收器**。
## ParNew GC
并行回收器是工作在新生代的垃圾回收器，它只简单地将串行回收器多线程化。它的回收策略、算法以及参数和串行回收器一样。并行回收器 也是**独占式**的回收器，在收集过程中，应用程序会全部暂停。但由于并行回收器使用多线程进行垃圾回收，因此，在并发能力比较强的 CPU 上，它产生的停顿时间要短于串行回收器，而在单 CPU 或者并发能力较弱的系统中，并行回收器的效果不会比串行回收器好，由于多线程的压力，它的实际表现很可能比串行回收器差。开启并行回收器可以使用参数-XX:+UseParNewGC，该参数设置新生代使用并行回收器，老年代使用串行回收器。老年代的并行回收回收器也是一种多线程并发的回收器。和新生代并行回收回收器一样，它也是一种关注吞吐量的回收器。老年代并行回收回收器使用标记-压缩算法，JDK1.6 之后开始启用。
## Parallel GC
Parallel Scavenge 收集器的特点是它的关注点与其他收集器不同，CMS 等收集器的关注点尽可能地**缩短垃圾收集时用户线程的停顿时间**，而 Parallel Scavenge 收集器的目标则是达到一个**可控制的吞吐量**（Throughput）。Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在JDK 1.6中才开始提供的。使用 -XX:+UseParallelOldGC 可以在新生代和老生代都使用并行回收回收器，这是一对非常关注吞吐量的垃圾回收器组合，在对吞吐量敏感的系统中，可以考虑使用。参数 -XX:ParallelGCThreads 也可以用于设置垃圾回收时的线程数量。  

Parallel收集器类假于ParNew并行收集器，它使用复制算法的收集器。从表面上看，它和并行收集器一样都是多线程、独占式的收集器。但是，并行回收收集器有一个重要的特点：它非常关注系统的吞吐量。
Parallel收集器可以使用以下参数启用：
-XX:+UseParallelGC:新生代使用并行回收收集器，老年代使用串行收集器。
-XX:+UseParallelOldGC:新生代和老年代都是用并行回收收集器。

这两个参数是矛盾的。因为停顿时间和吞吐量不可同时调优：
-XX:MaxGCPauseMills：最大停顿时间，单位毫秒。GC尽力保证回收时间不超过设定值。
-XX:GCTimeRatio：垃圾收集时间占总时间的比，0-100的取值范围，默认99，即最大允许1%时间做GC。
## CMS GC
CMS( Concurrent Mark-Sweep ) 是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器，适用于对停顿比较敏感，并且有相对较多存活时间较长的对象（老年代较大）的应用程序；不过 CMS 虽然减少了回收的停顿时间，但是降低了堆空间的利用率。

CMS GC 采用了 **Mark-Sweep 算法**，因此经过CMS收集的堆会产生**空间碎片**；为了解决堆空间浪费问题，CMS回收器不再采用简单的指针指向一块可用堆空间来为下次对象分配使用。而是把一些未分配的空间汇总成一个**列表**，当 JVM 分配对象空间的时候，会搜索这个列表找到足够大的空间来存放住这个对象。另一方面，由于 **CMS 线程和应用程序线程并发执行**，CMS GC 需要更多的 CPU 资源。同时，因为CMS标记阶段应用程序的线程还是在执行的，那么就会有堆空间继续分配的情况，为了保证在CMS回收完堆之前还有空间分配给正在运行的应用程序，必须预留一部分空间。也就是说，CMS不会在老年代满的时候才开始收集。相反，它会尝试更早的开始收集，已避免上面提到的情况：在回收完成之前，堆没有足够空间分配！默认当老年代使用68%的时候，CMS就开始行动了。 – XX:CMSInitiatingOccupancyFraction =n 来设置这个阀值。
### CMS GC 工作步骤如下所示：
* 初始标记(STW initial mark)：在这个阶段，需要**虚拟机停顿**正在执行的任务，官方的叫法STW(Stop The Word)。这个过程从垃圾回收的"根对象"开始，只扫描到能够和"根对象"直接关联的对象，并作标记。所以这个过程虽然暂停了整个JVM，但是很快就完成了。
* 并发标记(Concurrent marking)：这个阶段紧随初始标记阶段，在初始标记的基础上继续向下追溯标记。并发标记阶段，应用程序的线程和并发标记的线程并发执行，所以用户不会感受到停顿。  
* 并发预清理(Concurrent precleaning)：并发预清理阶段仍然是并发的。在这个阶段，虚拟机查找在执行并发标记阶段新进入老年代的对象(可能会有一些对象从新生代晋升到老年代，或者有一些对象被分配到老年代)。通过重新扫描，减少下一个阶段"重新标记"的工作，因为下一个阶段会Stop The World。  
* 重新标记(STW remark)：这个阶段会暂停虚拟机，回收器线程扫描在CMS堆中剩余的对象。扫描从"跟对象"开始向下追溯，并处理对象关联。
* 并发清理(Concurrent sweeping)：清理垃圾对象，这个阶段回收器线程和应用程序线程并发执行。 
* 并发重置(Concurrent reset)：这个阶段，重置CMS回收器的数据结构，等待下一次垃圾回收。

* 缺点：  

GC过程中会出现STW(Stop-The-World)，若Old区对象太多，STW耗费大量时间。  
CMS收集器对CPU资源很敏感。  
CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。  
CMS导致内存碎片问题。

## G1 GC

https://blog.csdn.net/zhou2s_101216/article/details/79202893

G1 GC 是 JDK 1.7 中正式投入使用的用于取代 CMS 的压缩回收器，它虽然没有在物理上隔断新生代与老生代，但是仍然属于分代垃圾回收器；G1 GC 仍然会区分年轻代与老年代，年轻代依然分有 Eden 区与 Survivor 区。G1 GC 首先将堆分为**大小相等**的 Region，避免全区域的垃圾收集，然后追踪每个 Region 垃圾堆积的**价值大小**，在后台维护一个**优先列表**，根据允许的收集时间优先回收价值最大的Region；同时 G1 GC 采用 **Remembered Set** 来存放 Region 之间的对象引用以及其他回收器中的新生代与老年代之间的对象引用，从而避免全堆扫描。  
G1 GC 的分区示例如下图所示：   
* 优点：   
随着 G1 GC 的出现，Java 垃圾回收器通过引入 Region 的概念，从传统的连续堆内存布局设计，逐步走向了物理上不连续但是逻辑上依旧连续的内存块；这样我们能够将某个 Region **动态地分配**给 Eden、Survivor、老年代、大对象空间、空闲区间等任意一个。每个 Region **都有一个**关联的 Remembered Set（简称RS），RS 的数据结构是 **Hash 表**，里面的数据是 Card Table （堆中每 512byte 映射在 card table 1byte）。简单的说RS里面存在的是**Region中存活对象的指针**。当Region中数据发生变化时，首先反映到Card Table中的一个或多个Card上，RS通过扫描内部的Card Table得知Region中内存使用情况和存活对象。在使用Region过程中，如果Region被填满了，分配内存的线程会重新选择一个新的Region，空闲Region被组织到一个基于链表的数据结构（LinkedList）里面，这样可以快速找到新的Region。
  

总结而言，G1 GC 的特性如下：  
* 并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力；
* 并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况；
* 分代GC：G1依然是一个分代回收器，但是和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；
* 空间整理：G1在回收过程中，会进行适当的对象移动，不像CMS只是简单地标记清理对象。在若干次GC后，CMS必须进行一次碎片整理。而G1不同，它每次回收都会有效地复制对象，减少空间碎片，进而提升内部循环速度；
*  可预见性：为了缩短停顿时间，G1建立可预存停顿的模型，这样在用户设置的停顿时间范围内，G1会选择适当的区域进行收集，确保停顿时间不超过用户指定时间。

* G1 GC 的工作步骤如下所示：
1. 初始标记（标记一下GC Roots能直接关联的对象并修改TAMS值，需要STW但耗时很短）
2. 并发标记（从GC Root从堆中对象进行可达性分析找存活的对象，耗时较长但可以与用户线程并发执行）
3. 最终标记（为了修正并发标记期间产生变动的那一部分标记记录，这一期间的变化记录在Remembered Set Log 里，然后合并到Remembered Set里，该阶段需要STW但是可并行执行）
4. 筛选回收（对各个Region回收价值排序，根据用户期望的GC停顿时间制定回收计划来回收）

Humongous区，它用来专门存放巨型对象。

G1提供了两种GC模式，Young GC和Mixed GC，两种都是Stop The World(STW)的

三色标记：黑灰白


* eden 和survivor 区比例为什么是8:1？  
8x1+2x1=10 因为经过统计，每次gc会有90%的对象被回收，所以要预留空间去保存剩下的10%  
只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。
为什么要设置两个Survivor区

设置两个Survivor区最大的好处就是解决了碎片化，永远有一个survivor space是空的，另一个非空的survivor space无碎片。
