- 树
  - 二叉树
  - 完全二叉树
  - 二叉平衡树
  - 自平衡
  - 二叉查找树
  - 红黑树
  - b树

## b+树



#### 新增
Index Page 已满新增，中间拆分
Leaf Page 已满新增，放进左右兄弟节点，也满则中间拆分，添加首位为索引
#### 删除
填充因子：记录少于时
Index Page 不少于填充因子数，合并叶及其兄弟节点，更新Index，少于则更新Index，合并Index及其兄弟节点

Leaf Page 不少于填充因子数，删除数据对应相同索引删除 ，右节点代替，少于则合并叶及其兄弟节点

树的查询效率高，而且可以保持有序

#### mysql 为何不用二叉查找树？

磁盘IO，索引加载进内存，索引次数为树的高度

#### 完全二叉树(Complete Binary Tree)
若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。

#### 二叉查找树（BST）具备什么特性呢？

（查找最大次数等于树高度）（快排）

1. 左子树上所有结点的值均小于或等于它的根结点的值。

2. 右子树上所有结点的值均大于或等于它的根结点的值。

3. 左、右子树也分别为二叉排序树。

4. 没有键值相等的节点（no duplicate nodes）。

* 缺点：数据插入可能造成只有单子树

#### 平衡二叉树（AVL树）：
求对于每一个节点来说，它的左右子树的高度之差不能超过1，如果插入或者删除一个节点使得高度之差大于1，就要进行节点之间的旋转，将二叉树重新维持在一个平衡状态。

左左(都是左子树长) <--> 右右
左左:右旋转原理：获取失去平衡结点以及左结点，为了让lchild作为根节点，将lchild的rchild挂接到之前左结点上，然后在挂接到s->rchild

左旋转原理正好相反，让其右结点作为根节点
左右 <--> 右左.（双旋转）
先转成左左或右右，在转
平衡度、平衡因子

#### 2-3树：不好理解

（2-3树的编码优化）红黑树

#### 红黑树（自平衡二叉树查找树）

性质：
1.节点是红色或黑色。
2.根节点是黑色。
3.每个叶子节点都是黑色的空节点（NIL（空）节点）。
4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。
注：叶子最长路径不会超过最短路径两倍

红黑树插入的结点为什么着为红色？
其实是保证性质5：如果每一次插入的都是黑色节点，那就和普通的树没有区别呢。所以，需要每次插入的是红色节点。

操作时根据新增结点与红黑树性质的冲突通过下面的操作组合调整：变色、左旋转、右旋转
记住，增加节点的时候，都是想方设法的让新增加的节点都是为红色，父亲节点为黑色。

#### B-树（多路平衡查找树）绝对平衡

结构矮胖

路数=关键字数+1

一个m阶（路）的B树具有如下几个特征：

1. 根结点至少有两个子女。

2. 每个中间节点都包含k-1个元素和k个孩子，其中 m/2 <= k <= m

3. 每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m

4. 所有的叶子结点都位于同一层。

5. 每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。

开区间

增：满，抽取中间关键字到上级节点

#### 一个m阶的B+树具有如下几个特征：

1. 有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。

2. 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。

3. 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素

左闭合

非叶子节点存关键字和子节点引用，不存数据

> 叶子有序链表
> 卫星数据（Satellite Information）

* B+树的特征：

1. 有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。

2. 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。

3. 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。

* B+树的优势：

1. 单一节点存储更多的元素，使得查询的IO次数更少。相同空间，查询更多关键字
2. 所有查询都要查找到叶子节点，查询性能稳定。效率稳定
3. 所有叶子节点形成有序链表，便于范围查询。

B*树：是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；
B*树分配新结点的概率比B+树要低，空间使用率更高；

### LSM树

LSM树的设计思想非常朴素：将对数据的修改增量保持在内存中，达到指定的大小限制后将这些修改操作批量写入磁盘，不过读取的时候稍微麻烦，需要合并磁盘中历史数据和内存中最近修改操作，所以写入性能大大提升，读取时可能需要先看是否命中内存，否则需要访问较多的磁盘文件。极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。