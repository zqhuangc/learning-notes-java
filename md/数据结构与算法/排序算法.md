## 1、插入排序：直接插入排序、二分法插入排序、希尔排序。
* 直接插入排序
```
从后往前判断移动数据插入
```
* 二分法插入排序
```
二分查找到位置，将数据往后移在插入
```
* 希尔排序
```
先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2（d1/2）
```

## 2、选择排序：直接选择排序、堆排序。 
#### 堆排序：(根->叶的每一条路线有序) 
**O(nlogn)** 
```java
http://www.cnblogs.com/MOBIN/p/5374217.html
图解实现
基本思想将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了
```

堆是具有以下性质的完全二叉树：
* 每个结点的值都大于或等于其**左右孩子**结点的值，称为大顶堆；
* 每个结点的值都小于或等于其**左右孩子**结点的值，称为小顶堆。 

*与左右（2i+1,2i+2）节点比较找出最值*  

 实现堆排序需要解决两个问题： 
 * 1、如何由一个无序序列建成一个堆？
 * 2、如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？
##### 核心
 * 步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。
   * 从最后一个非叶子结点开始（叶结点自然不用调整，**第一个非叶子结点 arr.length/2 - 1**,增量**2i+1**），从右至左(递减1))，从下至上(从尾至头)进行调整。
 * 步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆(步骤一)，再将堆顶元素与末尾元素交换，
   * 得到第二大元素。如此反复进行交换、重建、交换。

##### 直接选择排序:

## 3、交换排序：冒泡排序、快速排序。

* 冒泡排序：1、基本思想：在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。

* 快速排序：1、基本思想：选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分。

## 4、归并排序
```
 基本思想:归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。
 ```
## 5、基数排序、计数排序、桶排序
* 基数排序（每一位桶排序一次）
```
基本思想：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列
```
* 计数排序
```
  基本思想：输入一个数X，确定小于X的元素的个数，这样，就可以把这个数放在输出数组的指定位置上。 
  假设输入数组是A[1...n]，则需要一个辅助数组C[0...K]，一个输出数组B[1...n]。其中k代表输入数组中的最大值，n代表输入数组的长度。     
  其中，输入数组A是需要进行排序的一组数据，输出数组B是需要排序完成后的数据。辅助数组中是按键值存储该键值在输入数组中出现的次数。
  思路：
   1、初始化辅助数组。
   2、循环遍历每一个输入元素，如果一个输入元素为i,则辅助数组中相应的C[i]的值加1。执行完毕之后。数组C中存储的就是各个键值在输入数组中出现的次数。
   3、再通过加总计算确定对于从1到k，有多少个输入元素是小于等于k的。将结果赋值到数组C中。
   4、循环将A[J]放到它在输出数组的正确位置上。对于一个值来说，C[A[J]]的值就是它在输出数组B中的正确位置。

  当输入数组中的元素都是互异时，就比较好理解。但是当数组中有些元素相同时。 
  我们每将一个值放入输出数组中，都要将辅助数组中相应的值减1。这样，当存在下一个相同的值时，该元素可直接放在输出数组中相对应的位置上。  
```
**总结**：计数排序的时间复杂度为O(n)，计数排序最重要的特性是稳定。   
**缺点**：计数排序非常浪费空间。例如需要排序数的范围是0~2100000000之间，那你则需要申请2100000001个变量。  

## 桶排序：排序实质上与计数排序差异不大。
* 桶排序(二维）：数组+链表
```
基本思想:桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。然后将n个输入元素分别放入各自的桶中。因为输入时均匀独立的，所以一般不会有很多数同时落在一个桶中的情况。这样，我们想对各个桶中的数据进行排序，然后遍历每个桶，按照次序把各个桶中的元素列出来即可。 
```


