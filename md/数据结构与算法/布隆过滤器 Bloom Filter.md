**可先了解bitset和bitmap**

布隆过滤器本身就是基于位图的，是对位图的一种改进

大数据排序去重

### 位图（BitMap）

位图（**二维**数组值为（0，1）boolean型）（对应位置有值则为1）

```Java
long[] words; 
// (每一个long代表64个值，每一个下标代表一个组)  
//取模
int wordIndex = wordIndex(bitIndex) //对64取模（wordIndex）数组下标
words[wordIndex] |= (1L << bitIndex);  //对64取余再跟之前的的值取或（理解：1左移几位就代表余的值多少）

//由模跟余可判断原值  
//wordIndex*64+words[wordIndex]=原值
```

## Bloom filter

Bloom Filter 是一种空间效率很高的随机数据结构，Bloom filter 可以看做是对 bit-map 的扩展, 它的原理是：  
当一个元素被加入集合时，通过 K 个 Hash 函数将这个元素映射成一个位阵列（Bit array）中的 K 个点，把它们置为 1。检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有没有它了：
如果这些点有任何一个 0，则被检索元素一定不在；
如果都是 1，则被检索元素很可能在。

### 优点

它的优点是空间效率和查询时间都远远超过一般的算法，布隆过滤器存储空间和插入 / 查询时间都是常数O(k)。另外, 散列函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。
### 缺点  
但是布隆过滤器的缺点和优点一样明显。误算率是其中之一。随着存入的元素数量增加，误算率随之增加。但是如果元素数量太少，则使用散列表足矣。（多个值的hash，包含了其他值的hash）
(误判补救方法是：再建立一个小的白名单，存储那些可能被误判的信息。)   
另外，一般情况下不能从布隆过滤器中删除元素. 我们很容易想到把位数组变成整数数组，每插入一个元素相应的计数器加 1, 这样删除元素时将计数器减掉就可以了。然而要保证安全地删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面. 这一点单凭这个过滤器是无法保证的。另外计数器回绕也会造成问题。



#### 应用

* URL 去重
* 缓存击穿的保护
* 

